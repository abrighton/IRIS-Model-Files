subsystem = IRIS
component = oiwfs-poa-assembly

description = "OIWFS POA Assembly Commands."

receive = [
   {
    name            = init
    description     = """Prepares the assembly for operation and reads configuration files. (engineering)

This command will internally trigger a stop if required.

If configName and configVersion are not specified in the input, then the default configuration name and version will be used. If only configName is specified in the input, then the default version for the specified configName will be used. If only configVersion is specified in the input, then an error is returned.

*Discrete Command.*

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
<li> POS_state.cmd = BUSY
<li> MODE_state.cmd = BUSY
<li> POS_state.move1 = false
<li> POS_state.move2 = false
<li> POS_state.move3 = false
<li> MODE_state.move1 = false
<li> MODE_state.move2 = false
<li> MODE_state.move3 = false
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> POS_state.cmd = READY
<li> MODE_state.cmd = READY
</ul>"""
    args = [
       {
        name        = configName
        description = Name of the configuration file to get from the TMT Configuration Service
        type        = string
      }
      {
        name        = configVersion
        description = Version of the configuration file to get from the TMT Configuration Service
        type        = string
      }
    ]
  }

  {
    name            = park
    description     = """Park all the OIWFS POA stages by moving them to the safe maintenance/servicng positions.

This command will internally trigger a stop if required and then move all stage to park position as specified in the configuration file.


This command is intended to be used at the end of the night.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = datum
    description     = """Datum the OIWFS POA stages and prepares the assembly for operation.
If any stage is currently moving then this command will internally trigger a stop if required. This command will then position the POA at the default (parked) position.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
<li> POS_state.move1 = true
<li> POS_state.move2 = true
<li> POS_state.move3 = true
<li> MODE_state.move1 = true
<li> MODE_state.move2 = true
<li> MODE_state.move3 = true
<li> MODE_state.select1 = INTERMEDIATE
<li> MODE_state.select2 = INTERMEDIATE
<li> MODE_state.select3 = INTERMEDIATE
<li> current.datumR1 = false
<li> current.datumTheta1 = false
<li> current.datumTrombone1 = false
<li> current.datumCollimator1 = false
<li> current.datumTT1 = false
<li> current.datumTTF1 = false
<li> current.datumR2 = false
<li> current.datumTheta2 = false
<li> current.datumTrombone2 = false
<li> current.datumCollimator2 = false
<li> current.datumTT2 = false
<li> current.datumTTF2 = false
<li> current.datumR3 = false
<li> current.datumTheta3 = false
<li> current.datumTrombone3 = false
<li> current.datumCollimator3 = false
<li> current.datumTT3 = false
<li> current.datumTTF3 = false
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> POS_state.move1 = false
<li> POS_state.move2 = false
<li> POS_state.move3 = false
<li> MODE_state.move1 = false
<li> MODE_state.move2 = false
<li> MODE_state.move3 = false
<li> MODE_state.select1 = TT
<li> MODE_state.select2 = TT
<li> MODE_state.select3 = TT
</ul>"""
  }

  {
    name            = test
    description     = """Test the assembly connections.  There is no movement. (engineering)

The assembly will reconnect to its HCDs.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = debug
    description     = """Change the assembly debug message level. (engineering)

The assembly will log all messages that correspond to the current debug message level as well as all lower levels (e.g. if the current debug message level is INFO, then all INFO, WARN and ERROR messages will be logged). Below are the debug message levels in descending order.
<ul>
<li>	\b DEBUG: extra details as messages are processed
<li>	\b INFO : connections and command status
<li>	\b WARN(ing) : unexpected events/messages/etc
<li>	\b ERROR: failed to do something
</ul>

*Friendly Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> none
</ul>
At Completion:
<ul>
<li> state.debug = {input debug}
</ul>"""
    args = [
      {
        name        = debug
        description = target debug level
        enum        = [ DEBUG, INFO, WARN, ERROR ]
      }
    ]
    requiredArgs = [ debug ]
  }

  {
    name            = shutdown
    description     = """Shutdown the assembly. (engineering)

This command is used to properly shutdown the assembly in preparation to turn off the OIWFS Component Controller server.

*Simple Command.*

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = UNINITIALIZED
</ul>"""
  }

  {
    name            = stop
    description     = """Cancel the current discrete or following command and stop all OIWFS POA stages.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> POS_state.move1 = false
<li> POS_state.move2 = false
<li> POS_state.move3 = false
<li> MODE_state.move1 = false
<li> MODE_state.move3 = false
<li> MODE_state.move3 = false
</ul>"""
  }

  {
    name = MODE_init
   description     = """Prepares the MODE functional group for operation and reads configuration files. (engineering)

This command will internally trigger a stop if required.

If configName and configVersion are not specified in the input, then the default configuration name and version will be used. If only configName is specified in the input, then the default version for the specified configName will be used. If only configVersion is specified in the input, then an error is returned.

*Discrete Command.*

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> MODE_state.cmd = BUSY
<li> MODE_state.move1 = false
<li> MODE_state.move2 = false
<li> MODE_state.move3 = false
</ul>
At Completion:
<ul>
<li> MODE_state.cmd = READY
</ul>"""
  }

  {
    name            = MODE_datum
    description     = """Datum the MODE functional group stages and prepare for operation.
If any stage is currently moving then this command will internally trigger a MODE_stop if required. This command will then position the stages at the default position.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> MODE_state.move1 = true
<li> MODE_state.move2 = true
<li> MODE_state.move3 = true
<li> MODE_state.select1 = INTERMEDIATE
<li> MODE_state.select2 = INTERMEDIATE
<li> MODE_state.select3 = INTERMEDIATE
<li> current.datumTT1 = false
<li> current.datumTT2 = false
<li> current.datumTTF2 = false
<li> current.datumTT3 = false
<li> current.datumTTF3 = false
</ul>
At Completion:
<ul>
<li> MODE_state.move1 = false
<li> MODE_state.move2 = false
<li> MODE_state.move3 = false
<li> MODE_state.select1 = TT
<li> MODE_state.select2 = TT
<li> MODE_state.select3 = TT
</ul>"""
  }

  {
    name            = MODE_debug
    description     = """Change the MODE functional group debug message level. (engineering)

The assembly will log all messages that correspond to the current debug message level as well as all lower levels (e.g. if the current debug message level is INFO, then all INFO, WARN and ERROR messages will be logged). Below are the debug message levels in descending order.
<ul>
<li>	\b DEBUG: extra details as messages are processed
<li>	\b INFO : connections and command status
<li>	\b WARN(ing) : unexpected events/messages/etc
<li>	\b ERROR: failed to do something
</ul>

*Friendly Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> none
</ul>
At Completion:
<ul>
<li> state.debug = {input debug}
</ul>"""
    args = [
      {
        name        = debug
        description = target debug level
        enum        = [ DEBUG, INFO, WARN, ERROR ]
      }
    ]
    requiredArgs = [ debug ]
  }

  {
    name            = MODE_stop
    description     = """Cancel the current discrete command and stop all MODE functional group stages.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> MODE_state.move1 = false
<li> MODE_state.move3 = false
<li> MODE_state.move3 = false
</ul>"""
  }

  {
    name            = MODE_park
    description     = """Park all the MODE functional group stages by moving them to the safe maintenance/servicng positions.

This command will internally trigger a MODE_stop if required and then move all stage to park position as specified in the configuration file.

This command is intended to be used at the end of the night.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name = MODE_select
    description = """Configure the full set of probe optical modes.

The optical mode of each probe may be configured independently to one of the following values:
* **TT** mode inserts the Imaging Lens and retracts the Lenslet Array.
* **TTF** mode inserts the Lenslet Array and retracts the Imaging Lens.
* **OFF** mode retracts both lenses and parks associated probe.

Any probe for which no mode is specified will remain in its previously-configured mode.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> MODE_state.select1 = TT | TTF | OFF
<li> MODE_state.select3 = TT | TTF | OFF
<li> MODE_state.select3 = TT | TTF | OFF
</ul>"""
    args = [
      {
        name = probeType1
        description = "Optical mode of Probe 1"
        enum = [TT, TTF, OFF]
      }
      {
        name = probeType2
        description = "Optical mode of Probe 2"
        enum = [TT, TTF, OFF]
      }
      {
        name = probeType3
        description = "Optical mode of Probe 3"
        enum = [TT, TTF, OFF]
      }
    ]
  }

  {
    name            = MODE_test
    description     = """Test the MODE functional group connections.  There is no movement. (engineering)

The assembly will reconnect to its HCDs.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = POS_init
    description     = """Prepares the POS functional group for operation and reads configuration files. (engineering)

This command will internally trigger a stop if required.

*Discrete Command.*

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> POS_state.cmd = BUSY
<li> POS_state.move1 = false
<li> POS_state.move2 = false
<li> POS_state.move3 = false
</ul>
At Completion:
<ul>
<li> POS_state.cmd = READY
</ul>"""
    args = [
       {
        name        = configName
        description = Name of the configuration file to get from the TMT Configuration Service
        type        = string
      }
      {
        name        = configVersion
        description = Version of the configuration file to get from the TMT Configuration Service
        type        = string
      }
    ]
  }

  {
    name            = POS_datum
    description     = """Datum the POS functional group and prepares the assembly for operation.

If any stage is currently moving then this command will internally trigger a stop if required. This command will then position the POA at the default (parked) position.

*Discrete Command.*

Precondition:
<ul>
<li> POS_state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> POS_state.move1 = true
<li> POS_state.move2 = true
<li> POS_state.move3 = true
<li> current.datumR1 = false
<li> current.datumTheta1 = false
<li> current.datumTrombone1 = false
<li> current.datumCollimator1 = false
<li> current.datumR2 = false
<li> current.datumTheta2 = false
<li> current.datumTrombone2 = false
<li> current.datumCollimator2 = false
<li> current.datumR3 = false
<li> current.datumTheta3 = false
<li> current.datumTrombone3 = false
<li> current.datumCollimator3 = false
</ul>
At Completion:
<ul>
<li> POS_state.move1 = false
<li> POS_state.move2 = false
<li> POS_state.move3 = false
</ul>"""
  }

  {
    name            = POS_debug
    description     = """Change the POS functional group debug message level. (engineering)

The assembly will log all messages that correspond to the current debug message level as well as all lower levels (e.g. if the current debug message level is INFO, then all INFO, WARN and ERROR messages will be logged). Below are the debug message levels in descending order.
<ul>
<li>	\b DEBUG: extra details as messages are processed
<li>	\b INFO : connections and command status
<li>	\b WARN(ing) : unexpected events/messages/etc
<li>	\b ERROR: failed to do something
</ul>

*Friendly Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> none
</ul>
At Completion:
<ul>
<li> state.debug = {input debug}
</ul>"""
    args = [
      {
        name        = debug
        description = target debug level
        enum        = [ DEBUG, INFO, WARN, ERROR ]
      }
    ]
    requiredArgs = [ debug ]
  }

  {
    name            = POS_test
    description     = """Test the POS functional group connections.  There is no movement. (engineering)

The assembly will reconnect to its HCDs.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name = POS_move
    description = """Move probes to the target X,Y position in FCRS<sub>IRIS-ROT</sub> coordinates and stop.

At least one input parameter must be specified, an unspecified stage will remain unchanged.

All stages related to probe positioning must be datumed, otherwise this command will fail.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
<li> POS_state.move1 = true
<li> POS_state.move2 = true
<li> POS_state.move3 = true
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>
"""

    requiredArgs = [moveFlag, moveCoords]
    args = [
      {
        name = x1
        description = "target x coordinate of Probe 1"
        units = mm
        type = float
      }
      {
        name = y1
        description = "target y coordinate of Probe 1"
        units = mm
        type = float
      }
      {
        name = x2
        description = "target x coordinate of Probe 2"
        units = mm
        type = float
      }
      {
        name = y2
        description = "target y coordinate of Probe 2"
        units = mm
        type = float
      }
      {
        name = x3
        description = "target x coordinate of Probe 3"
        units = mm
        type = float
      }
      {
        name = y3
        description = "target y coordinate of Probe 3"
        units = mm
        type = float
      }
    ]
  }

  {
    name = POS_follow
    description = """Activate probe position following.

When the follow mode is enabled, the OIWFS POA probes will track natural guide star positions published by the TCS in FCRS<sub>IRIS-ROT</sub>.

While following, the assembly subscribes to the aosq.iris.oiwfs.active event stream to determine which probes are currently active. Active probes will not be affected by probes that are moving to new targets, and probes that are moving to new targets will navigate around probes that are currently active. Until the first event is received, it is assumed that no probes are active.

Any static offsets specified by the POS_offset command are added to the continually varying positions from the TCS (e.g., to account for guide star catalog position errors).

While following, the optional RTC offset arguments are used to indicate whether a given probe should add continually varying offsets published by the RTC (e.g., position error offloading if the OIWFS is not being used to provide TT information).

The behaviour of any unspecified command argument will remain unchanged from its previously commanded behavior.

The POA stages associated with probe motion must be datumed otherwise this command will be rejected.

*Discrete Command.*

Precondition:
<ul>
<li> POS_state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> POS_state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> POS_state.cmd = CONTINUOUS
</ul>

"""

    args = [
      {
        name = follow1
        description = "Probe 1 following TCS if true."
        type = boolean
      }
      {
        name = rtcOffset1
        description = "Probe 1 applying RTC offsets to TCS follow stream if true."
        type = boolean
      }
      {
        name = follow2
        description = "Probe 2 following TCS if true."
        type = boolean
      }
      {
        name = rtcOffset2
        description = "Probe 2 applying RTC offsets to TCS follow stream if true."
        type = boolean
      }
      {
        name = follow3
        description = "Probe 3 following TCS if true."
        type = boolean
      }
      {
        name = rtcOffset3
        description = "Probe 3 applying RTC offsets to TCS follow stream if true."
        type = boolean
      }
    ]
  }

  {
    name = POS_offset
    description = """Provide static x,y probe positional offsets w.r.t. TCS demands in FCRS<sub>IRIS-ROT</sub> coordinates.

Any static offsets specified by the POS_offset command are added to the continually varying positions from the TCS when the POS_follow command has been used to activate following (e.g., to account for guide star catalog position errors).

The behaviour of any unspecified command argument will remain unchanged from its previously commanded behavior.

The POA stages associated with probe motion must be datumed otherwise this command will be rejected.

*Discrete Command.*

Precondition:
<ul>
<li> POS_state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> POS_state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> POS_state.cmd = CONTINUOUS
</ul>

"""
    args = [
      {
        name = xOffset1
        description = "x offset to apply to Probe 1 when following."
        units = mm
        type = float
      }
      {
        name = yOffset1
        description = "y offset to apply to Probe 1 when following."
        units = mm
        type = float
      }
      {
        name = xOffset2
        description = "x offset to apply to Probe 2 when following."
        units = mm
        type = float
      }
      {
        name = yOffset2
        description = "y offset to apply to Probe 2 when following."
        units = mm
        type = float
      }
      {
        name = xOffset3
        description = "x offset to apply to Probe 3 when following."
        units = mm
        type = float
      }
      {
        name = yOffset3
        description = "y offset to apply to Probe 3 when following."
        units = mm
        type = float
      }
    ]
  }

  {
    name = POS_filter
    description = """Activate and set parameters of a low-pass filter to TCS demand streams when following.

When the active attribute is set for a given probe, a low-pass Butterworth filter is applied to TCS demands when following, parameterized by the order and cutoff frequency attributes.

The behaviour of any unspecified command argument will remain unchanged from its previously commanded behavior.

The POA stages associated with probe motion must be datumed otherwise this command will be rejected.

*Discrete Command.*

Precondition:
<ul>
<li> POS_state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> POS_state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> POS_state.cmd = CONTINUOUS
</ul>

"""
    args = [
      {
        name = active1
        description = "filter active for Probe 1 when true"
        type = boolean
      }
      {
        name = order1
        description = "order of Butterworth filter for Probe 1"
        minimum = 1
        type = integer
      }
      {
        name = cutoff1
        description = "cutoff frequency of Butterworth filter for Probe 1"
        minimum = 0
        units = Hz
        type = float
      }
      {
        name = active2
        description = "filter active for Probe 2 when true"
        type = boolean
      }
      {
        name = order2
        description = "order of Butterworth filter for Probe 2"
        minimum = 1
        type = integer
      }
      {
        name = cutoff2
        description = "cutoff frequency of Butterworth filter for Probe 2"
        minimum = 0
        units = Hz
        type = float
      }
      {
        name = active3
        description = "filter active for Probe 3 when true"
        type = boolean
      }
      {
        name = order3
        description = "order of Butterworth filter for Probe 3"
        minimum = 1
        type = integer
      }
      {
        name = cutoff3
        description = "cutoff frequency of Butterworth filter for Probe 3"
        minimum = 0
        units = Hz
        type = float
      }

    ]
  }

  {
    name            = POS_stop
    description     = """Cancel the current POS functional group discrete or following command and stop all relevant stages.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> POS_state.move1 = false
<li> POS_state.move2 = false
<li> POS_state.move3 = false
</ul>"""
  }

  {
    name            = POS_park
    description     = """Park all the POS functional group stages by moving them to the safe maintenance/servicng positions.

This command will internally trigger a POS_stop if required and then move all stage to park position as specified in the configuration file.

This command is intended to be used at the end of the night.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = POS_recover
    description     = """Recover from a collision.

Using switch information published by the Galil IO HCD, rotate the probes involved in the collision until they are no longer in contact, and place them into a safe state for POS_datum command.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name = POS_trackingType
    description = """Configure the tracking/dithering type for each probe.

The POS_trackingType command will set the tracking/dithering type for the OIWFS probes at a specified future time. This command has no effect on any probe that has been set to OFF with the MODE_select command.

Each probe may be in one of the following tracking modes:

* TRACK_POA: Tracking using POA
* TRACK_ON_CHIP: Tracking using on-chip sub window offset with POA locked.
* DITHER_POA: Dithering using POA
* DITHER_ON_CHIP: Dithering using on-chip sub window offset with POA locked

The difference between TRACK and DITHER is that no science exposure is happening during DITHER and therefore relaxed accuracy is allowed (i.e., different regions of the guide and acquisition table are used for detector readouts). This mode is only meaningful after executing the POS_follow command. The *_ON_CHIP variants indicate that the probes are stationary while the readout windows move, while the remaining variants involve motion of the probes.

An optional timestamp can be provided to specify when in the future the command should take effect.

The behaviour of any unspecified command argument will remain unchanged from its previously commanded behavior.

*Discrete Command.*

Precondition:
<ul>
<li> POS_state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> POS_state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> POS_state.cmd = CONTINUOUS
</ul>

"""

    args = [
      {
        name = trackingType1
        description = "Tracking/dithering mode for Probe 1"
        enum = [ TRACK_POA, TRACK_ON_CHIP, DITHER_POA, DITHER_ON_CHIP ]
      }
      {
        name = trackingType2
        description = "Tracking/dithering mode for Probe 2"
        enum = [ TRACK_POA, TRACK_ON_CHIP, DITHER_POA, DITHER_ON_CHIP ]
      }
      {
        name = trackingType3
        description = "Tracking/dithering mode for Probe 3"
        enum = [ TRACK_POA, TRACK_ON_CHIP, DITHER_POA, DITHER_ON_CHIP ]
      }      {
        name = timestamp
        description = "Time at which the command should take effect"
        type = taiDate
        units = "TAI / PTP"
      }
    ]
  }

]
